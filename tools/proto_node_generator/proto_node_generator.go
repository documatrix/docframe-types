package main

import (
	"bufio"
	"flag"
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/sirupsen/logrus"
)

// ignoreTypeComment can be used to mark a Proto message as ignored by the generator.
// Therefore no Node conversion will be written for it.
const ignoreTypeComment = "// go-gen:ignore"

func main() {
	protoDocumentElementDir := flag.String("proto-document-element-dir", "", "The directory which contains the proto file per document element")
	protoUtilDir := flag.String("proto-util-dir", "", "The directory which contains the proto file per util message")
	destinationDir := flag.String("destination-dir", "", "The directory which should contain the generated files.")
	flag.Parse()

	if *protoDocumentElementDir == "" {
		logrus.Errorf("No document element proto source folder specified!")
		os.Exit(1)
	}

	if *protoUtilDir == "" {
		logrus.Errorf("No util proto source folder specified!")
		os.Exit(1)
	}

	if *destinationDir == "" {
		logrus.Errorf("No destination directory specified!")
		os.Exit(1)
	}

	err := workDir(*protoDocumentElementDir, *destinationDir)
	if err != nil {
		logrus.Errorf("Error processing directory %s: %s", *protoDocumentElementDir, err.Error())
		os.Exit(1)
	}
}

func workDir(dir string, destinationDir string) error {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return fmt.Errorf("error reading docframe proto files: %w", err)
	}

	for _, file := range entries {
		fileName := file.Name()
		if fileName == "documentelements.branch_document_element.proto" || fileName == "documentelements.document_element.proto" {
			continue
		}

		if strings.HasSuffix(fileName, ".proto") {
			goFile := strings.ReplaceAll(fileName, ".proto", "_generated.go")
			err = generateFromProto(filepath.Join(dir, fileName), filepath.Join(destinationDir, goFile))
			if err != nil {
				return fmt.Errorf("error generating Go file out of %q: %w", fileName, err)
			}
		}
	}

	return nil
}

var messageRegex = regexp.MustCompile(`message (\w+)\s*\{`)

var elementTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by docframe document element generator
package docframepb

{{ range .Elements }}
func ({{ .CamelProtoType }} *{{ .ProtoTypeName }}) ToNode(children ...Message) *Node {
	nodeChildren := make([]*Node, len(children))
	for i, c := range children {
		nodeChildren[i] = c.ToNode()
	}

	node := &Node{
		Object: &Node_{{ .TypeName }}{
			{{ .TypeName }}: {{ .ProtoTypeName }},
		},
		Children: nodeChildren,
	}

	return node
}
{{ end }}
`))

type ElementData struct {
	CamelProtoType string
	ProtoTypeName  string
	TypeName       string
}

func generateFromProto(protoFile string, goFile string) error {
	proto, err := os.Open(protoFile)
	if err != nil {
		return fmt.Errorf("error opening %q for reading: %w", protoFile, err)
	}
	defer proto.Close()

	fileScanner := bufio.NewScanner(proto)

	fileScanner.Split(bufio.ScanLines)

	elements := []*ElementData{}

	var currentElement *ElementData

	ignoreNext := false
	for fileScanner.Scan() {
		line := fileScanner.Text()
		if strings.HasPrefix(line, ignoreTypeComment) {
			ignoreNext = true
			continue
		}

		if match := messageRegex.FindStringSubmatch(line); match != nil {
			if currentElement != nil {
				elements = append(elements, currentElement)
			}

			typeName := strings.ReplaceAll(match[1], "Proto", "")
			if ignoreNext {
				currentElement = nil
				ignoreNext = false
				continue
			}

			currentElement = &ElementData{
				ProtoTypeName:  match[1],
				CamelProtoType: strcase.ToCamel(match[1]),
				TypeName:       typeName,
			}
		}

		ignoreNext = false
	}

	if currentElement != nil {
		elements = append(elements, currentElement)
	}

	if len(elements) == 0 {
		logrus.Infof("No type found in proto file %s", protoFile)
		return nil
	}

	goFH, err := os.Create(goFile)
	if err != nil {
		return fmt.Errorf("error creating go file %q: %w", goFile, err)
	}
	defer goFH.Close()

	return elementTemplate.Execute(goFH, struct {
		Elements []*ElementData
	}{
		Elements: elements,
	})
}
