package main

import (
	"bufio"
	"flag"
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/sirupsen/logrus"
)

// ignoreTypeComment can be used to mark a Proto message as ignored by the generator.
// Therefore no Node conversion will be written for it.
const ignoreTypeComment = "// go-gen:ignore"

func main() {
	protoDocumentElementsDir := flag.String(
		"proto-document-elements-dir",
		"",
		"The directory which contains the proto file per document element",
	)
	protoUtilsDir := flag.String(
		"proto-utils-dir",
		"",
		"The directory which contains the proto file per util message",
	)
	destinationDir := flag.String(
		"destination-dir",
		"",
		"The directory which should contain the generated files.",
	)
	flag.Parse()

	if *protoDocumentElementsDir == "" {
		logrus.Errorf("No document element proto source folder specified!")
		os.Exit(1)
	}

	if *protoUtilsDir == "" {
		logrus.Errorf("No util proto source folder specified!")
		os.Exit(1)
	}

	if *destinationDir == "" {
		logrus.Errorf("No destination directory specified!")
		os.Exit(1)
	}

	err := workDir(*protoDocumentElementsDir, *destinationDir)
	if err != nil {
		logrus.Errorf("Error processing directory %s: %s", *protoDocumentElementsDir, err.Error())
		os.Exit(1)
	}

	converterFile, err := os.Create(filepath.Join(*destinationDir, "converter_generated.go"))
	if err != nil {
		logrus.Errorf("Error creating message file: %s", err.Error())
		os.Exit(1)
	}
	defer converterFile.Close()

	converterFile.WriteString(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by docframe document element generator
package document_elementsv1

import (
	"fmt"

	"google.golang.org/protobuf/proto"
)

type Message interface {
	proto.Message

	ToNode(children ...Message) *Node
}

func (n *Node) ToNode(...Message) *Node {
	return n
}

type Protos []Message

func (protos Protos) ToProtoBytes() ([]byte, error) {
	rootNode := &Node{}

	var err error

	rootNode.Children = make([]*Node, len(protos))

	for i, p := range protos {
		rootNode.Children[i] = p.ToNode()
	}

	data, err := proto.Marshal(rootNode)
	if err != nil {
		return nil, fmt.Errorf("error marshalling root node: %w", err)
	}

	return data, nil
}
`)
}

func workDir(dir string, destinationDir string) error {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return fmt.Errorf("error reading docframe proto files: %w", err)
	}

	for _, file := range entries {
		fileName := file.Name()
		if strings.HasSuffix(fileName, ".proto") {
			goFile := strings.ReplaceAll(fileName, ".proto", "_generated.go")
			err = generateFromProto(
				filepath.Join(dir, fileName),
				filepath.Join(destinationDir, goFile),
			)
			if err != nil {
				return fmt.Errorf("error generating Go file out of %q: %w", fileName, err)
			}
		}
	}

	return nil
}

var messageRegex = regexp.MustCompile(`message (\w+)\s*\{`)

var elementTemplate = template.Must(
	template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by docframe document element generator
package document_elementsv1

{{ range .Elements }}
func ({{ .CamelProtoType }} *{{ .ProtoTypeName }}) ToNode(children ...Message) *Node {
	nodeChildren := make([]*Node, len(children))
	for i, c := range children {
		nodeChildren[i] = c.ToNode()
	}

	node := &Node{
		Object: &Node_{{ .TypeName }}{
			{{ .TypeName }}: {{ .ProtoTypeName }},
		},
		Children: nodeChildren,
	}

	return node
}
{{ end }}
`),
)

type ElementData struct {
	CamelProtoType string
	ProtoTypeName  string
	TypeName       string
}

func generateFromProto(protoFile string, goFile string) error {
	proto, err := os.Open(protoFile)
	if err != nil {
		return fmt.Errorf("error opening %q for reading: %w", protoFile, err)
	}
	defer proto.Close()

	fileScanner := bufio.NewScanner(proto)

	fileScanner.Split(bufio.ScanLines)

	elements := []*ElementData{}

	var currentElement *ElementData

	ignoreNext := false
	for fileScanner.Scan() {
		line := fileScanner.Text()
		if strings.HasPrefix(line, ignoreTypeComment) {
			ignoreNext = true
			continue
		}

		if match := messageRegex.FindStringSubmatch(line); match != nil {
			if currentElement != nil {
				elements = append(elements, currentElement)
			}

			typeName := strings.ReplaceAll(match[1], "Proto", "")
			if ignoreNext {
				currentElement = nil
				ignoreNext = false
				continue
			}

			currentElement = &ElementData{
				ProtoTypeName:  match[1],
				CamelProtoType: strcase.ToCamel(match[1]),
				TypeName:       typeName,
			}
		}

		ignoreNext = false
	}

	if currentElement != nil {
		elements = append(elements, currentElement)
	}

	if len(elements) == 0 {
		logrus.Infof("No type found in proto file %s", protoFile)
		return nil
	}

	goFH, err := os.Create(goFile)
	if err != nil {
		return fmt.Errorf("error creating go file %q: %w", goFile, err)
	}
	defer goFH.Close()

	return elementTemplate.Execute(goFH, struct {
		Elements []*ElementData
	}{
		Elements: elements,
	})
}
