package main

import (
	"bufio"
	"flag"
	"fmt"
	"html/template"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/iancoleman/strcase"
	"github.com/sirupsen/logrus"
)

var ignoreTypes = map[string]bool{
	// DocumentElement types
	"TableSettings":              true,
	"TableContentGroupSettings":  true,
	"TableRowSettings":           true,
	"TableCellSettings":          true,
	"BoxedTableContentGroupType": true,
	"BoxedTableCellType":         true,

	// Util types
	"AdvancedIllustrationArea":                  true,
	"BoxedAdvancedIllustrationAreaTextFlowType": true,
	"BoxedHorizontalAlignment":                  true,
	"BoxedVerticalAlignment":                    true,
	"BoxedColor":                                true,
	"BoxedFont":                                 true,
	"BoxedListSetting":                          true,
	"BoxedMeasure":                              true,
	"BoxedPositionMode":                         true,
	"BoxedSPB":                                  true,
	"BoxedSPBMode":                              true,
	"BoxedStrikethrough":                        true,
	"BoxedStrikethroughSpec":                    true,
	"BoxedUnderline":                            true,
	"BoxedUnderlineSpec":                        true,
	"CMYKColor":                                 true,
	"RGBColor":                                  true,
	"SideBorders":                               true,
	"SideMeasures":                              true,
}

func main() {
	protoDocumentElementDir := flag.String("proto-document-element-dir", "", "The directory which contains the proto file per document element")
	protoUtilDir := flag.String("proto-util-dir", "", "The directory which contains the proto file per util message")
	destinationDir := flag.String("destination-dir", "", "The directory which should contain the generated files.")
	flag.Parse()

	if *protoDocumentElementDir == "" {
		logrus.Errorf("No document element proto source folder specified!")
		os.Exit(1)
	}

	if *protoUtilDir == "" {
		logrus.Errorf("No util proto source folder specified!")
		os.Exit(1)
	}

	if *destinationDir == "" {
		logrus.Errorf("No destination directory specified!")
		os.Exit(1)
	}

	err := workDir(*protoDocumentElementDir, *destinationDir, "DOCUMENT_ELEMENT")
	if err != nil {
		logrus.Errorf("Error processing directory %s: %s", *protoDocumentElementDir, err.Error())
		os.Exit(1)
	}

	err = workDir(*protoUtilDir, *destinationDir, "UTIL")
	if err != nil {
		logrus.Errorf("Error processing directory %s: %s", *protoUtilDir, err.Error())
		os.Exit(1)
	}
}

func workDir(dir string, destinationDir string, nodeTypePrefix string) error {
	entries, err := os.ReadDir(dir)
	if err != nil {
		return fmt.Errorf("error reading docframe proto files: %w", err)
	}

	for _, file := range entries {
		fileName := file.Name()
		if fileName == "documentelements.branch_document_element.proto" || fileName == "documentelements.document_element.proto" {
			continue
		}

		if strings.HasSuffix(fileName, ".proto") {
			goFile := strings.ReplaceAll(fileName, ".proto", "_generated.go")
			err = generateFromProto(filepath.Join(dir, fileName), filepath.Join(destinationDir, goFile), nodeTypePrefix)
			if err != nil {
				return fmt.Errorf("error generating Go file out of %q: %w", fileName, err)
			}
		}
	}

	return nil
}

var messageRegex = regexp.MustCompile(`message (\w+)\s*\{`)

var elementTemplate = template.Must(template.New("").Parse(`// Code generated by go generate; DO NOT EDIT.
// This file was generated by docframe document element generator
package docframepb

{{ range .Elements }}
func ({{ .CamelProtoType }} *{{ .ProtoTypeName }}) ToNode(children ...Message) *Node {
	nodeChildren := make([]*Node, len(children))
	for i, c := range children {
		nodeChildren[i] = c.ToNode()
	}

	node := &Node{
		Object: &Node_{{ .TypeName }}{
			{{ .TypeName }}: {{ .ProtoTypeName }},
		},
		Children: nodeChildren,
	}

	return node
}
{{ end }}
`))

type ElementData struct {
	CamelProtoType string
	ProtoTypeName  string
	TypeName       string
}

func generateFromProto(protoFile string, goFile string, nodeTypePrefix string) error {
	proto, err := os.Open(protoFile)
	if err != nil {
		return fmt.Errorf("error opening %q for reading: %w", protoFile, err)
	}
	defer proto.Close()

	fileScanner := bufio.NewScanner(proto)

	fileScanner.Split(bufio.ScanLines)

	elements := []*ElementData{}

	var currentElement *ElementData

	for fileScanner.Scan() {
		line := fileScanner.Text()
		if match := messageRegex.FindStringSubmatch(line); match != nil {
			if currentElement != nil {
				elements = append(elements, currentElement)
			}

			typeName := strings.ReplaceAll(match[1], "Proto", "")
			if _, ok := ignoreTypes[typeName]; ok {
				currentElement = nil
				continue
			}

			currentElement = &ElementData{
				ProtoTypeName:  match[1],
				CamelProtoType: strcase.ToCamel(match[1]),
				TypeName:       typeName,
			}
		}
	}

	if currentElement != nil {
		elements = append(elements, currentElement)
	}

	if len(elements) == 0 {
		logrus.Infof("No type found in proto file %s", protoFile)
		return nil
	}

	goFH, err := os.Create(goFile)
	if err != nil {
		return fmt.Errorf("error creating go file %q: %w", goFile, err)
	}
	defer goFH.Close()

	return elementTemplate.Execute(goFH, struct {
		Elements []*ElementData
	}{
		Elements: elements,
	})
}
